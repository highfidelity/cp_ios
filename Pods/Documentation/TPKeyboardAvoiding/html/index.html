<!DOCTYPE HTML>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>TPKeyboardAvoiding 0.0.1 Reference</title>
		<link rel="stylesheet" type="text/css" href="css/styles.css" media="all" />
		<link rel="stylesheet" type="text/css" media="print" href="css/stylesPrint.css" />
		<meta name="generator" content="appledoc 2.1 (build 840)" />
	</head>
	<body>
		<header id="top_header">
			<div id="library" class="hideInXcode">
				<h1><a id="libraryTitle" href="index.html">TPKeyboardAvoiding 0.0.1 </a></h1>
				<a id="developerHome" href="index.html">Michael Tyson</a>
			</div>
			
			<div id="title" role="banner">
				<h1 class="hideInXcode">TPKeyboardAvoiding 0.0.1 Reference</h1>
			</div>
			<ul id="headerButtons" role="toolbar"></ul>
		</header>
		<article>
			<div id="overview_contents" role="main">
				<div class="main-navigation navigation-top">
					<a href="hierarchy.html">Next</a>
				</div>
				<div id="header">
					<div class="section-header">
						<h1 class="title title-header">TPKeyboardAvoiding 0.0.1 Reference</h1>
					</div>		
				</div>
				<div id="container">
					
					<div class="section section-overview index-overview">
						
						
						<h1>TPKeyboardAvoiding</h1>

<p>A drop-in universal solution for moving text fields out of the way of the keyboard in iOS.</p>

<h2>Introduction</h2>

<p>There are a hundred and one proposed solutions out there for how to move <code>UITextField</code> and <code>UITextView</code> out of the way of the keyboard during editing &mdash; usually, it comes down to observing <code>UIKeyboardWillShowNotification</code> and <code>UIKeyboardWillHideNotification</code>, or implementing <code>UITextFieldDelegate</code> delegate methods, and adjusting the frame of the superview, or using <code>UITableView</code>&rsquo;s <code>scrollToRowAtIndexPath:atScrollPosition:animated:</code>, but most proposed solutions tend to be quite DIY, and have to be implemented for each view controller that needs it.</p>

<p>This is a relatively universal, drop-in solution: <code>UIScrollView</code> and <code>UITableView</code> subclasses that handle everything.</p>

<p>When the keyboard is about to appear, the subclass will find the subview that&rsquo;s about to be edited, and adjust its frame and content offset to make sure that view is visible, with an animation to match the keyboard pop-up. When the keyboard disappears, it restores its prior size.</p>

<p>It should work with basically any setup, either a UITableView-based interface, or one consisting of views placed manually.</p>

<h2>Usage</h2>

<p>For use with <code>UITableViewController</code> classes, drop <a href="Classes/TPKeyboardAvoidingTableView.html"><code>TPKeyboardAvoidingTableView</code></a>.m<code>and</code><a href="Classes/TPKeyboardAvoidingTableView.html"><code>TPKeyboardAvoidingTableView</code></a>.h<code>into your project, and make your UITableView a</code><a href="Classes/TPKeyboardAvoidingTableView.html"><code>TPKeyboardAvoidingTableView</code></a> in the xib.  If you&rsquo;re not using a xib with your controller, I know of no easy way to make its UITableView a custom class: The path of least resistance is to create a xib for it.</p>

<p>For non-UITableViewControllers, drop the <a href="Classes/TPKeyboardAvoidingScrollView.html"><code>TPKeyboardAvoidingScrollView</code></a>.m<code>and</code><a href="Classes/TPKeyboardAvoidingScrollView.html"><code>TPKeyboardAvoidingScrollView</code></a>.h<code>source files into your project, pop a</code>UIScrollView<code>into your view controller's xib, set the scroll view's class to</code><a href="Classes/TPKeyboardAvoidingScrollView.html"><code>TPKeyboardAvoidingScrollView</code></a>, and put all your controls within that scroll view.  You can also create it programmatically, without using a xib &ndash; just use the <a href="Classes/TPKeyboardAvoidingScrollView.html">TPKeyboardAvoidingScrollView</a> as your top-level view.</p>

<h2>Notes</h2>

<p>On iOS 4.3 and up, UITableView automatically supports moving out of the way of the keyboard.  Thus, using <a href="Classes/TPKeyboardAvoidingTableView.html">TPKeyboardAvoidingTableView</a> on iOS 4.3+ environments will have no effect &mdash; in fact, if iOS 4.3 or up is detected, the init methods for <a href="Classes/TPKeyboardAvoidingTableView.html">TPKeyboardAvoidingTableView</a> will return a UITableView instead.</p>

<p>These classes currently adjust the contentInset parameter to avoid content moving beneath the keyboard.  This is done, as opposed to adjusting the frame, in order to work around an iOS bug that results in a jerky animation where the view jumps upwards, before settling down.  In order to facilitate this workaround, the contentSize is maintained to be at least same size as the view&rsquo;s frame.</p>

<h2>Licence</h2>

<p>Free for commercial use and redistribution in any form.  Credit is appreciated but not essential.  Oh, and there aint no warranty!</p>

<p>Michael Tyson, A Tasty Pixel<br/>
michael@atastypixel.com</p>
						
						
					</div>
					
                        
                    
					
					
					<div class="index-column">
						<h2 class="index-title">Class References</h2>
						<ul>
							
							<li><a href="Classes/TPKeyboardAvoidingScrollView.html">TPKeyboardAvoidingScrollView</a></li>
							
							<li><a href="Classes/TPKeyboardAvoidingTableView.html">TPKeyboardAvoidingTableView</a></li>
							
						</ul>
					</div>
					
					
					
				</div>
				<div class="main-navigation navigation-bottom">
					<a href="hierarchy.html">Next</a>
				</div>
				<div id="footer">
					<hr />
					<div class="footer-copyright">
						<p><span class="copyright">&copy; 2012 Michael Tyson. All rights reserved. (Last updated: 2012-10-24)</span><br />
						
						<span class="generator">Generated by <a href="http://appledoc.gentlebytes.com">appledoc 2.1 (build 840)</a>.</span></p>
						
	
					</div>
				</div>
			</div>
		</article>		
	</body>
</html>